{% extends "base.html" %}
{% from "partials/components.html" import page_header %}
{% from "partials/icons.html" import refresh_cw %}
{% block title %}Containers - Compose Farm{% endblock %}

{% block content %}
<div class="max-w-7xl">
    {{ page_header("Containers", "All running containers across hosts") }}

    {% if not glances_enabled %}
    <div class="alert alert-warning mb-6">
        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
        <div>
            <h3 class="font-bold">Glances not configured</h3>
            <div class="text-xs">Add <code class="bg-base-300 px-1 rounded">glances_stack: glances</code> to your config and deploy Glances on all hosts.</div>
        </div>
    </div>
    {% else %}

    <!-- Action Bar -->
    <div class="flex flex-wrap items-center gap-4 mb-6">
        <button class="btn btn-outline btn-sm" hx-get="/api/containers/rows" hx-target="#container-rows" hx-swap="innerHTML">
            {{ refresh_cw() }} Refresh
        </button>
        <input type="text" id="filter-input" placeholder="Filter containers..."
               class="input input-bordered input-sm w-64" onkeyup="filterTable()">
        <span id="container-count" class="text-sm text-base-content/60"></span>
        <div class="ml-auto flex items-center gap-2">
            <span class="badge badge-ghost font-mono text-xs" id="refresh-timer"></span>
        </div>
    </div>

    <!-- Container Table -->
    <div class="card bg-base-100 shadow overflow-x-auto">
        <table class="table table-zebra table-sm w-full">
            <thead class="sticky top-0 bg-base-200">
                <tr>
                    <th class="w-8">#</th>
                    <th class="cursor-pointer" onclick="sortTable(1)">Stack<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(2)">Service<span class="sort-indicator"></span></th>
                    <th></th>
                    <th class="cursor-pointer" onclick="sortTable(4)">Host<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(5)">Image<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(6)">Status<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(7)">Uptime<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(8)">CPU<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(9)">Mem<span class="sort-indicator"></span></th>
                    <th class="cursor-pointer" onclick="sortTable(10)">Net I/O<span class="sort-indicator"></span></th>
                </tr>
            </thead>
            <tbody id="container-rows"
                   hx-get="/api/containers/rows"
                   hx-trigger="load"
                   hx-swap="innerHTML">
                <tr><td colspan="11" class="text-center py-8">
                    <span class="loading loading-spinner loading-md"></span>
                    <span class="ml-2">Loading containers...</span>
                </td></tr>
            </tbody>
        </table>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
{% if glances_enabled %}
<style>
.sort-indicator { display: inline-block; width: 1em; text-align: center; opacity: 0.5; }
</style>
<script>
// Simple client-side filtering
function filterTable() {
    const filter = document.getElementById('filter-input').value.toLowerCase();
    const rows = document.querySelectorAll('#container-rows tr');
    let visible = 0;
    rows.forEach(row => {
        const text = row.textContent.toLowerCase();
        const show = text.includes(filter);
        row.style.display = show ? '' : 'none';
        if (show) visible++;
    });
    document.getElementById('container-count').textContent =
        filter ? `${visible} matching` : '';
}

// Client-side sorting using data-sort attributes (set by server on every cell)
let sortCol = 8, sortAsc = false;  // Default: CPU (col 8) descending
const numericCols = new Set([7, 8, 9, 10]);  // uptime, cpu, mem, net

function sortTable(col) {
    if (sortCol === col) {
        sortAsc = !sortAsc;
    } else {
        sortCol = col;
        sortAsc = false;
    }
    updateSortIndicators();
    doSort();
}

function updateSortIndicators() {
    document.querySelectorAll('thead th').forEach((th, i) => {
        const span = th.querySelector('.sort-indicator');
        if (span) {
            span.textContent = (i === sortCol) ? (sortAsc ? '↑' : '↓') : '';
            span.style.opacity = (i === sortCol) ? '1' : '0.3';
        }
    });
}

function doSort() {
    const tbody = document.getElementById('container-rows');
    const rows = Array.from(tbody.querySelectorAll('tr'));
    if (rows.length === 0) return;

    const isNumeric = numericCols.has(sortCol);
    rows.sort((a, b) => {
        const aVal = a.cells[sortCol]?.dataset?.sort ?? '';
        const bVal = b.cells[sortCol]?.dataset?.sort ?? '';
        const cmp = isNumeric ? aVal - bVal : aVal.localeCompare(bVal);
        return sortAsc ? cmp : -cmp;
    });

    rows.forEach((row, i) => {
        row.cells[0].textContent = i + 1;  // Update row index after sort
        tbody.appendChild(row);
    });
}

// Re-apply filter and sort after HTMX swap, reset timer
let lastUpdate = Date.now();
const REFRESH_INTERVAL = 3000;
// Use window.refreshPaused so it can be detected/set from outside (e.g., dropdown focus)
window.refreshPaused = false;

document.body.addEventListener('htmx:afterSwap', (e) => {
    if (e.detail.target.id === 'container-rows') {
        lastUpdate = Date.now();
        doSort();  // Re-apply current sort
        const filter = document.getElementById('filter-input').value;
        if (filter) filterTable();
    }
});

// Manual polling with pause support
function refreshContainers() {
    if (!window.refreshPaused) {
        htmx.ajax('GET', '/api/containers/rows', {target: '#container-rows', swap: 'innerHTML'});
    }
}

// Poll every 3 seconds using JavaScript (not HTMX's every trigger)
setInterval(refreshContainers, REFRESH_INTERVAL);

// Detect dropdown open/close via focusin/focusout (these bubble, unlike focus/blur)
document.body.addEventListener('focusin', (e) => {
    if (e.target.closest('.dropdown')) {
        window.refreshPaused = true;
    }
});

document.body.addEventListener('focusout', (e) => {
    if (e.target.closest('.dropdown')) {
        // Small delay to allow clicking menu items before dropdown loses focus
        setTimeout(() => {
            // Only resume if no dropdown element is focused
            if (!document.activeElement?.closest('.dropdown')) {
                window.refreshPaused = false;
            }
        }, 150);
    }
});

// Resume refresh when Escape is pressed (focusout doesn't fire on Escape)
document.body.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && window.refreshPaused) {
        setTimeout(() => {
            window.refreshPaused = false;
        }, 100);
    }
});

// Update timer display every 100ms
setInterval(() => {
    const timer = document.getElementById('refresh-timer');
    if (window.refreshPaused) {
        timer.textContent = '⏸';
        return;
    }
    const elapsed = Date.now() - lastUpdate;
    const remaining = Math.max(0, REFRESH_INTERVAL - elapsed);
    const remainingSec = Math.ceil(remaining / 1000);
    timer.textContent = `↻ ${remainingSec}s`;
}, 100);

// Show initial sort indicator
document.addEventListener('DOMContentLoaded', updateSortIndicators);
</script>
{% endif %}
{% endblock %}
