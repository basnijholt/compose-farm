"""Configuration management commands for compose-farm."""

from __future__ import annotations

import os
import platform
import shlex
import shutil
import subprocess
from importlib import resources
from pathlib import Path
from typing import Annotated

import typer

from compose_farm.cli.app import app
from compose_farm.console import MSG_CONFIG_NOT_FOUND, console, print_error, print_success
from compose_farm.paths import config_search_paths, default_config_path, find_config_path

config_app = typer.Typer(
    name="config",
    help="Manage compose-farm configuration files.",
    no_args_is_help=True,
)


# --- CLI Options (same pattern as cli.py) ---
_PathOption = Annotated[
    Path | None,
    typer.Option("--path", "-p", help="Path to config file. Uses auto-detection if not specified."),
]
_ForceOption = Annotated[
    bool,
    typer.Option("--force", "-f", help="Overwrite existing config without confirmation."),
]
_RawOption = Annotated[
    bool,
    typer.Option("--raw", "-r", help="Output raw file contents (for copy-paste)."),
]
_DiscoverOption = Annotated[
    bool,
    typer.Option(
        "--discover", "-d", help="Auto-detect compose files and interactively select stacks."
    ),
]


def _get_editor() -> str:
    """Get the user's preferred editor ($EDITOR > $VISUAL > platform default)."""
    if editor := os.environ.get("EDITOR") or os.environ.get("VISUAL"):
        return editor
    if platform.system() == "Windows":
        return "notepad"
    return next((e for e in ("nano", "vim", "vi") if shutil.which(e)), "vi")


def _generate_template() -> str:
    """Generate a config template with documented schema."""
    try:
        template_file = resources.files("compose_farm") / "example-config.yaml"
        return template_file.read_text(encoding="utf-8")
    except FileNotFoundError as e:
        print_error("Example config template is missing from the package")
        console.print("Reinstall compose-farm or report this issue.")
        raise typer.Exit(1) from e


def _get_config_file(path: Path | None) -> Path | None:
    """Resolve config path, or auto-detect from standard locations."""
    if path:
        return path.expanduser().resolve()

    config_path = find_config_path()
    return config_path.resolve() if config_path else None


def _generate_discovered_config(
    compose_dir: Path,
    hostname: str,
    host_address: str,
    selected_stacks: list[str],
) -> str:
    """Generate config YAML from discovered stacks."""
    import yaml  # noqa: PLC0415

    config_data = {
        "compose_dir": str(compose_dir),
        "hosts": {hostname: host_address},
        "stacks": dict.fromkeys(selected_stacks, hostname),
    }

    header = """\
# Compose Farm configuration
# Documentation: https://github.com/basnijholt/compose-farm
#
# Generated by: cf config init --discover

"""
    return header + yaml.dump(config_data, default_flow_style=False, sort_keys=False)


def _interactive_stack_selection(stacks: list[str]) -> list[str]:
    """Interactively select stacks to include."""
    from rich.prompt import Confirm, Prompt  # noqa: PLC0415

    console.print("\n[bold]Found stacks:[/bold]")
    for stack in stacks:
        console.print(f"  [cyan]{stack}[/cyan]")

    console.print()

    # Fast path: include all
    if Confirm.ask(f"Include all {len(stacks)} stacks?", default=True):
        return stacks

    # Let user specify which to exclude
    console.print(
        "\n[dim]Enter stack names to exclude (comma-separated), or press Enter to select individually:[/dim]"
    )
    exclude_input = Prompt.ask("Exclude", default="")

    if exclude_input.strip():
        exclude = {s.strip() for s in exclude_input.split(",")}
        return [s for s in stacks if s not in exclude]

    # Fall back to individual selection
    console.print()
    return [
        stack for stack in stacks if Confirm.ask(f"  Include [cyan]{stack}[/cyan]?", default=True)
    ]


def _run_discovery_flow() -> str | None:
    """Run the interactive discovery flow and return generated config content."""
    import socket  # noqa: PLC0415

    from rich.prompt import Prompt  # noqa: PLC0415

    console.print("[bold]Compose Farm Config Discovery[/bold]")
    console.print("[dim]This will scan for compose files and generate a config.[/dim]\n")

    # Step 1: Get compose directory
    default_dir = Path.cwd()
    compose_dir_str = Prompt.ask(
        "Compose directory",
        default=str(default_dir),
    )
    compose_dir = Path(compose_dir_str).expanduser().resolve()

    if not compose_dir.exists():
        print_error(f"Directory does not exist: {compose_dir}")
        return None

    if not compose_dir.is_dir():
        print_error(f"Path is not a directory: {compose_dir}")
        return None

    # Step 2: Discover stacks
    from compose_farm.config import discover_compose_dirs  # noqa: PLC0415

    console.print(f"\n[dim]Scanning {compose_dir}...[/dim]")
    stacks = discover_compose_dirs(compose_dir)

    if not stacks:
        print_error(f"No compose files found in {compose_dir}")
        console.print("[dim]Each stack should be in a subdirectory with a compose.yaml file.[/dim]")
        return None

    console.print(f"[green]Found {len(stacks)} stack(s)[/green]")

    # Step 3: Interactive selection
    selected_stacks = _interactive_stack_selection(stacks)

    if not selected_stacks:
        console.print("\n[yellow]No stacks selected.[/yellow]")
        return None

    # Step 4: Get hostname and address
    default_hostname = socket.gethostname()
    hostname = Prompt.ask("\nHost name", default=default_hostname)
    host_address = Prompt.ask("Host address", default="localhost")

    # Step 5: Generate config
    console.print(f"\n[dim]Generating config with {len(selected_stacks)} stack(s)...[/dim]")
    return _generate_discovered_config(compose_dir, hostname, host_address, selected_stacks)


def _report_missing_config(explicit_path: Path | None = None) -> None:
    """Report that a config file was not found."""
    console.print("[yellow]Config file not found.[/yellow]")
    if explicit_path:
        console.print(f"\nProvided path does not exist: [cyan]{explicit_path}[/cyan]")
    else:
        console.print("\nSearched locations:")
        for p in config_search_paths():
            status = "[green]exists[/green]" if p.exists() else "[dim]not found[/dim]"
            console.print(f"  - {p} ({status})")
    console.print("\nRun [bold cyan]cf config init[/bold cyan] to create one.")


@config_app.command("init")
def config_init(
    path: _PathOption = None,
    force: _ForceOption = False,
    discover: _DiscoverOption = False,
) -> None:
    """Create a new config file with documented example.

    The generated config file serves as a template showing all available
    options with explanatory comments.

    Use --discover to auto-detect compose files and interactively select
    which stacks to include.
    """
    target_path = (path.expanduser().resolve() if path else None) or default_config_path()

    if target_path.exists() and not force:
        console.print(
            f"[bold yellow]Config file already exists at:[/bold yellow] [cyan]{target_path}[/cyan]",
        )
        if not typer.confirm("Overwrite existing config file?"):
            console.print("[dim]Aborted.[/dim]")
            raise typer.Exit(0)

    if discover:
        template_content = _run_discovery_flow()
        if template_content is None:
            raise typer.Exit(0)
    else:
        template_content = _generate_template()

    # Create parent directories
    target_path.parent.mkdir(parents=True, exist_ok=True)

    # Write config file
    target_path.write_text(template_content, encoding="utf-8")

    print_success(f"Config file created at: {target_path}")
    console.print("\n[dim]Edit the file to customize your settings:[/dim]")
    console.print("  [cyan]cf config edit[/cyan]")


@config_app.command("edit")
def config_edit(
    path: _PathOption = None,
) -> None:
    """Open the config file in your default editor.

    The editor is determined by: $EDITOR > $VISUAL > platform default.
    """
    config_file = _get_config_file(path)

    if config_file is None:
        _report_missing_config()
        raise typer.Exit(1)

    if not config_file.exists():
        _report_missing_config(config_file)
        raise typer.Exit(1)

    editor = _get_editor()
    console.print(f"[dim]Opening {config_file} with {editor}...[/dim]")

    try:
        editor_cmd = shlex.split(editor, posix=os.name != "nt")
    except ValueError as e:
        print_error("Invalid editor command. Check [bold]$EDITOR[/]/[bold]$VISUAL[/]")
        raise typer.Exit(1) from e

    if not editor_cmd:
        print_error("Editor command is empty")
        raise typer.Exit(1)

    try:
        subprocess.run([*editor_cmd, str(config_file)], check=True)
    except FileNotFoundError:
        print_error(f"Editor [cyan]{editor_cmd[0]}[/] not found")
        console.print("Set [bold]$EDITOR[/] environment variable to your preferred editor.")
        raise typer.Exit(1) from None
    except subprocess.CalledProcessError as e:
        print_error(f"Editor exited with error code {e.returncode}")
        raise typer.Exit(e.returncode) from None


@config_app.command("show")
def config_show(
    path: _PathOption = None,
    raw: _RawOption = False,
) -> None:
    """Display the config file location and contents."""
    config_file = _get_config_file(path)

    if config_file is None:
        _report_missing_config()
        raise typer.Exit(0)

    if not config_file.exists():
        _report_missing_config(config_file)
        raise typer.Exit(1)

    content = config_file.read_text(encoding="utf-8")

    if raw:
        print(content, end="")
        return

    from rich.syntax import Syntax  # noqa: PLC0415

    console.print(f"[bold green]Config file:[/bold green] [cyan]{config_file}[/cyan]")
    console.print()
    syntax = Syntax(content, "yaml", theme="monokai", line_numbers=True, word_wrap=True)
    console.print(syntax)
    console.print()
    console.print("[dim]Tip: Use -r for copy-paste friendly output[/dim]")


@config_app.command("path")
def config_path(
    path: _PathOption = None,
) -> None:
    """Print the config file path (useful for scripting)."""
    config_file = _get_config_file(path)

    if config_file is None:
        _report_missing_config()
        raise typer.Exit(1)

    # Just print the path for easy piping
    print(config_file)


@config_app.command("validate")
def config_validate(
    path: _PathOption = None,
) -> None:
    """Validate the config file syntax and schema."""
    config_file = _get_config_file(path)

    if config_file is None:
        print_error(MSG_CONFIG_NOT_FOUND)
        raise typer.Exit(1)

    # Lazy import: pydantic adds ~50ms to startup, only load when actually needed
    from compose_farm.config import load_config  # noqa: PLC0415

    try:
        cfg = load_config(config_file)
    except FileNotFoundError as e:
        print_error(str(e))
        raise typer.Exit(1) from e
    except Exception as e:
        print_error(f"Invalid config: {e}")
        raise typer.Exit(1) from e

    print_success(f"Valid config: {config_file}")
    console.print(f"  Hosts: {len(cfg.hosts)}")
    console.print(f"  Stacks: {len(cfg.stacks)}")


@config_app.command("symlink")
def config_symlink(
    target: Annotated[
        Path | None,
        typer.Argument(help="Config file to link to. Defaults to ./compose-farm.yaml"),
    ] = None,
    force: _ForceOption = False,
) -> None:
    """Create a symlink from the default config location to a config file.

    This makes a local config file discoverable globally without copying.
    Always uses absolute paths to avoid broken symlinks.

    Examples:
        cf config symlink                    # Link to ./compose-farm.yaml
        cf config symlink /opt/compose/config.yaml  # Link to specific file

    """
    # Default to compose-farm.yaml in current directory
    target_path = (target or Path("compose-farm.yaml")).expanduser().resolve()

    if not target_path.exists():
        print_error(f"Target config file not found: {target_path}")
        raise typer.Exit(1)

    if not target_path.is_file():
        print_error(f"Target is not a file: {target_path}")
        raise typer.Exit(1)

    symlink_path = default_config_path()

    # Check if symlink location already exists
    if symlink_path.exists() or symlink_path.is_symlink():
        if symlink_path.is_symlink():
            current_target = symlink_path.resolve() if symlink_path.exists() else None
            if current_target == target_path:
                print_success(f"Symlink already points to: {target_path}")
                return
            # Update existing symlink
            if not force:
                existing = symlink_path.readlink()
                console.print(f"[yellow]Symlink exists:[/] {symlink_path} -> {existing}")
                if not typer.confirm(f"Update to point to {target_path}?"):
                    console.print("[dim]Aborted.[/dim]")
                    raise typer.Exit(0)
            symlink_path.unlink()
        else:
            # Regular file exists
            print_error(f"A regular file exists at: {symlink_path}")
            console.print("    Back it up or remove it first, then retry.")
            raise typer.Exit(1)

    # Create parent directories
    symlink_path.parent.mkdir(parents=True, exist_ok=True)

    # Create symlink with absolute path
    symlink_path.symlink_to(target_path)

    print_success("Created symlink:")
    console.print(f"    {symlink_path}")
    console.print(f"    -> {target_path}")


_ListOption = Annotated[
    bool,
    typer.Option("--list", "-l", help="List available example templates."),
]


@config_app.command("example")
def config_example(
    name: Annotated[
        str | None,
        typer.Argument(help="Example template name (e.g., whoami, full)"),
    ] = None,
    output_dir: Annotated[
        Path | None,
        typer.Option("--output", "-o", help="Output directory. Defaults to current directory."),
    ] = None,
    list_examples: _ListOption = False,
    force: _ForceOption = False,
) -> None:
    """Generate example stack files from built-in templates.

    Examples:
        cf config example --list           # List available examples
        cf config example whoami           # Generate whoami stack in ./whoami/
        cf config example full             # Generate complete Traefik + whoami setup
        cf config example nginx -o /opt/compose  # Generate in specific directory

    """
    from compose_farm.examples import (  # noqa: PLC0415
        EXAMPLES,
        SINGLE_STACK_EXAMPLES,
        list_example_files,
    )

    # List mode
    if list_examples:
        console.print("[bold]Available example templates:[/bold]\n")
        console.print("[dim]Single stack examples:[/dim]")
        for example_name, description in SINGLE_STACK_EXAMPLES.items():
            console.print(f"  [cyan]{example_name}[/cyan] - {description}")
        console.print()
        console.print("[dim]Complete setup:[/dim]")
        console.print(f"  [cyan]full[/cyan] - {EXAMPLES['full']}")
        console.print()
        console.print("[dim]Usage: cf config example <name>[/dim]")
        return

    # Interactive selection if no name provided
    if name is None:
        from rich.prompt import Prompt  # noqa: PLC0415

        console.print("[bold]Available example templates:[/bold]\n")
        example_names = list(EXAMPLES.keys())
        for i, (example_name, description) in enumerate(EXAMPLES.items(), 1):
            console.print(f"  [{i}] [cyan]{example_name}[/cyan] - {description}")

        console.print()
        choice = Prompt.ask(
            "Select example",
            choices=[str(i) for i in range(1, len(example_names) + 1)] + example_names,
            default="1",
        )

        # Handle numeric or name input
        name = example_names[int(choice) - 1] if choice.isdigit() else choice

    # Validate example name
    if name not in EXAMPLES:
        print_error(f"Unknown example: {name}")
        console.print(f"Available examples: {', '.join(EXAMPLES.keys())}")
        raise typer.Exit(1)

    # Determine output directory
    base_dir = (output_dir or Path.cwd()).expanduser().resolve()
    # For 'full' example, use current dir; for single stacks, create subdir
    target_dir = base_dir if name == "full" else base_dir / name

    # Check for existing files
    files = list_example_files(name)
    existing_files = [f for f, _ in files if (target_dir / f).exists()]
    if existing_files and not force:
        console.print(f"[yellow]Files already exist in:[/yellow] {target_dir}")
        console.print(f"[dim]  {len(existing_files)} file(s) would be overwritten[/dim]")
        if not typer.confirm("Overwrite existing files?"):
            console.print("[dim]Aborted.[/dim]")
            raise typer.Exit(0)

    # Create directories and copy files
    for rel_path, content in files:
        file_path = target_dir / rel_path
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content, encoding="utf-8")
        console.print(f"  [green]Created[/green] {file_path}")

    print_success(f"Example '{name}' created at: {target_dir}")

    # Show appropriate next steps
    if name == "full":
        console.print("\n[dim]Next steps:[/dim]")
        console.print(f"  1. Edit [cyan]{target_dir}/compose-farm.yaml[/cyan] with your host IP")
        console.print("  2. Edit [cyan].env[/cyan] files with your domain")
        console.print("  3. Create Docker network: [cyan]docker network create mynetwork[/cyan]")
        console.print("  4. Deploy: [cyan]cf up traefik whoami[/cyan]")
    else:
        console.print("\n[dim]Next steps:[/dim]")
        console.print(f"  1. Edit [cyan]{target_dir}/.env[/cyan] with your settings")
        console.print(f"  2. Add to compose-farm.yaml: [cyan]{name}: <hostname>[/cyan]")
        console.print(f"  3. Deploy with: [cyan]cf up {name}[/cyan]")


# Register config subcommand on the shared app
app.add_typer(config_app, name="config", rich_help_panel="Configuration")
